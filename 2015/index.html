<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>2015</title>

    <script type="text/javascript" src="gl-matrix-min.js"></script>

    <style media="screen">
      html, body, #canvas {
        height: 100%;
        width: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: black;
        color: white;
        text-align: center;
        font-family: monospace;
        line-height: 100vh;
      }
    </style>

    <script type="text/javascript">
      'use strict';

      /**
        TODO:
           - Overlay text
           - Clean Constants
           - xz movement and limits
           - Add pixel shader effects
            - Blurs
      **/
      var context = {
            canvas: null,
            gl: null
          },
          render = {
            mvMatrix: null,
            shaderProgram: null,
            mvUniform: null,
            nUniform: null,
          },
          objectState = {
            lastCubeUpdateTime: null,
            objects: []
          };

      /*
        Render initializations
      */
      function initContext() {
        // Initialize gl context
        context.canvas = document.getElementById("canvas");
        context.gl = context.canvas.getContext("webgl") ||
                     context.canvas.getContext("experimental-webgl");

        // Check compatibility
        if (!context.gl) {
          throw 'WebGL not available :(';
        }

        // Set clear color to black, fully opaque
        context.gl.clearColor(0.0, 0.0, 0.0, 1.0);
        // Enable depth testing
        context.gl.enable(context.gl.DEPTH_TEST);
        // Near things obscure far things
        context.gl.depthFunc(context.gl.LEQUAL);
        // Clear the color as well as the depth buffer.
        context.gl.clear(context.gl.COLOR_BUFFER_BIT | context.gl.DEPTH_BUFFER_BIT);
      }

      function getShader(id) {
        var shaderScript, theSource, currentChild, shader;
        shaderScript = document.getElementById(id);

        if (!shaderScript) {
          return null;
        }

        theSource = "";
        currentChild = shaderScript.firstChild;

        while(currentChild) {
          if (currentChild.nodeType == currentChild.TEXT_NODE) {
            theSource += currentChild.textContent;
          }

          currentChild = currentChild.nextSibling;
        }

        if (shaderScript.type == "x-shader/x-fragment") {
          shader = context.gl.createShader(context.gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
          shader = context.gl.createShader(context.gl.VERTEX_SHADER);
        } else {
           // Unknown shader type
           return null;
        }
        context.gl.shaderSource(shader, theSource);

        // Compile the shader program
        context.gl.compileShader(shader);

        // See if it compiled successfully
        if (!context.gl.getShaderParameter(shader, context.gl.COMPILE_STATUS)) {
            throw("An error occurred compiling the shaders: " + context.gl.getShaderInfoLog(shader));
        }

        return shader;
      }

      function initSize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        context.gl.viewport(0, 0, canvas.width, canvas.height);

        // Define the prespective
        var perspectiveMatrix = mat4.perspective(mat4.create(),
                                                 Math.PI*2/8,
                                                 canvas.width/canvas.height,
                                                 25,
                                                 55);
        var pUniform = context.gl.getUniformLocation(render.shaderProgram, "uPMatrix");
        context.gl.uniformMatrix4fv(pUniform, false, new Float32Array(perspectiveMatrix));
      }

      function initRender() {

        // Set up shaders
        var fragmentShader = getShader("shader-fs");
        var vertexShader = getShader("shader-vs");

        render.shaderProgram = context.gl.createProgram();
        context.gl.attachShader(render.shaderProgram, vertexShader);
        context.gl.attachShader(render.shaderProgram, fragmentShader);
        context.gl.linkProgram(render.shaderProgram);

        if (!context.gl.getProgramParameter(render.shaderProgram, context.gl.LINK_STATUS)) {
          throw("Unable to initialize the shader program.");
        }

        context.gl.useProgram(render.shaderProgram);

        render.mvUniform = context.gl.getUniformLocation(render.shaderProgram, "uMVMatrix");
        render.nUniform = context.gl.getUniformLocation(render.shaderProgram, "uNormalMatrix");

        // Create vertices
        var vertices = [
           1.0,  0.0, -1/Math.sqrt(2),
          -1.0,  0.0, -1/Math.sqrt(2),
           0.0,  1.0,  1/Math.sqrt(2),

          -1.0,  0.0, -1/Math.sqrt(2),
           1.0,  0.0, -1/Math.sqrt(2),
           0.0, -1.0,  1/Math.sqrt(2),

           1.0,  0.0, -1/Math.sqrt(2),
           0.0,  1.0,  1/Math.sqrt(2),
           0.0, -1.0,  1/Math.sqrt(2),

          -1.0,  0.0, -1/Math.sqrt(2),
           0.0, -1.0,  1/Math.sqrt(2),
           0.0,  1.0,  1/Math.sqrt(2),
        ];

        var vertexPositionAttribute = context.gl.getAttribLocation(render.shaderProgram, "aVertexPosition");
        context.gl.enableVertexAttribArray(vertexPositionAttribute);

        var cubeVerticesBuffer = context.gl.createBuffer();
        context.gl.bindBuffer(context.gl.ARRAY_BUFFER, cubeVerticesBuffer);
        context.gl.bufferData(context.gl.ARRAY_BUFFER, new Float32Array(vertices), context.gl.STATIC_DRAW);
        context.gl.vertexAttribPointer(vertexPositionAttribute, 3, context.gl.FLOAT, false, 0, 0);

        var cubeVertexIndices = [
          0,  1,  2,   // Top
          3,  4,  5,   // Bottom
          6,  7,  8,   // Right
          9,  10, 11,  // Left
        ];
        var cubeVerticesIndexBuffer = context.gl.createBuffer();
        context.gl.bindBuffer(context.gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);
        context.gl.bufferData(context.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), context.gl.STATIC_DRAW);

        // Create normals
        var vertexNormals = [
          0, 1, -1/Math.sqrt(2),
          0, 1, -1/Math.sqrt(2),
          0, 1, -1/Math.sqrt(2),

          0, -1, -1/Math.sqrt(2),
          0, -1, -1/Math.sqrt(2),
          0, -1, -1/Math.sqrt(2),

          1, 0, 1/Math.sqrt(2),
          1, 0, 1/Math.sqrt(2),
          1, 0, 1/Math.sqrt(2),

          -1, 0, 1/Math.sqrt(2),
          -1, 0, 1/Math.sqrt(2),
          -1, 0, 1/Math.sqrt(2),
        ]

        var vertexNormalAttribute = context.gl.getAttribLocation(render.shaderProgram, "aVertexNormal");
        context.gl.enableVertexAttribArray(vertexNormalAttribute);

        var cubeVerticesNormalBuffer = context.gl.createBuffer();
        context.gl.bindBuffer(context.gl.ARRAY_BUFFER, cubeVerticesNormalBuffer);
        context.gl.bufferData(context.gl.ARRAY_BUFFER, new Float32Array(vertexNormals), context.gl.STATIC_DRAW);
        context.gl.vertexAttribPointer(vertexNormalAttribute, 3, context.gl.FLOAT, false, 0, 0);
      }

      /*
        Drawing
      */
      function drawScene() {
        // Clear draw surface
        context.gl.clear(context.gl.COLOR_BUFFER_BIT | context.gl.DEPTH_BUFFER_BIT);

        // Calculate movement
        var currentTime = (new Date).getTime();
        var delta = currentTime - (objectState.lastCubeUpdateTime ||Â (new Date).getTime());

        // Draw
        for (var i = 0 ; i < objectState.objects.length ; i++) {
          var currentObject = objectState.objects[i];

          // Calculate object position matrix
          var objectMatrix = mat4.create();
          var rotation = quat.setAxisAngle(currentObject.rotation.base,
                                           currentObject.rotation.vector,
                                           currentObject.rotation.angle);
          mat4.fromRotationTranslation(objectMatrix, rotation, currentObject.translation);
          var normalMatrix = mat4.create();
          mat4.invert(normalMatrix, objectMatrix);
          mat4.transpose(normalMatrix, normalMatrix);

          // Render object
          context.gl.uniformMatrix4fv(render.mvUniform, false, new Float32Array(objectMatrix));
          context.gl.uniformMatrix4fv(render.nUniform, false, new Float32Array(normalMatrix));
          context.gl.drawElements(context.gl.TRIANGLES, 12, context.gl.UNSIGNED_SHORT, 0);

          // Update object
          currentObject.rotation.angle = (currentObject.rotation.angle + delta / 3000.0) % (2*Math.PI);
          currentObject.translation[1] = currentObject.translation[1] - delta/1400.0;
          if (currentObject.translation[1] < -25) {
            currentObject.translation[1] = 25;
          }
        }

        objectState.lastCubeUpdateTime = currentTime;
      }

      function setMatrixUniforms() {
        context.gl.uniformMatrix4fv(render.mvUniform, false, new Float32Array(render.mvMatrix.flatten()));

        var normalMatrix = render.mvMatrix.inverse().transpose();
        context.gl.uniformMatrix4fv(render.nUniform, false, new Float32Array(normalMatrix.flatten()));
      }

      /*
        Object handling
      */
      function initObjects() {
        var count = 200,
            size = 50;
        objectState.objects = [];

        for (var i = 0 ; i < count ; i++) {
          objectState.objects[i] = {
            translation: vec3.fromValues(
              Math.random()*size-size/2,
              Math.random()*size-size/2,
              Math.random()*size/2-size/4-40.0
            ),
            rotation: {
              base: quat.setAxisAngle(quat.create(),
                                      Math.random()*2*Math.PI,
                                      vec3.normalize(vec3.create(),
                                                     vec3.fromValues(
                                                        Math.random()-0.5,
                                                        Math.random()-0.5,
                                                        Math.random()-0.5))),
              angle: Math.random()*2*Math.PI,
              vector: vec3.normalize(vec3.create(), vec3.fromValues(
                       Math.random()-0.5,
                       Math.random()-0.5,
                       Math.random()-0.5))
            }
          }
        }
      }

      /*
        Runner
      */
      function start() {
        initContext();
        initRender();
        initObjects();
        initSize();
        setInterval(drawScene, 50);

        window.onresize = initSize;
      }

      window.onload = function onload() {
        start();
      };
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
      varying mediump vec3 vLighting;

      void main(void) {
        gl_FragColor = vec4(vLighting, 1.0);
      }
    </script>

    <script id="shader-vs" type="x-shader/x-vertex">
      attribute mediump vec3 aVertexNormal;
      attribute vec3 aVertexPosition;

      uniform mediump mat4 uNormalMatrix;
      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;

      varying mediump vec3 vLighting;

      void main(void) {
        vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * mvPosition;

        // Environment
        mediump vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);
        mediump vec3 uPointLightingLocation = vec3(0, 0, -40);
        mediump vec3 lightVector = uPointLightingLocation - mvPosition.xyz;
        mediump float lightDistance = length(lightVector);
        mediump vec3 lightDirection = normalize(lightVector);
        mediump vec3 eyeDirection = normalize(vec3(0,0,5));

        // Ambient lighting
        mediump vec3 ambientLightColor = normalize(vec3(0.9, 0.8, 0.4));
        mediump float ambientLuminance = 10.0;

        // Directional lighting
        mediump vec3 directionalLightColor = normalize(vec3(0.9, 0.8, 0.4))*150.0;
        mediump float directionalLuminance = max(dot(transformedNormal.xyz, lightDirection), 0.0);

        // Specular lighting
        mediump vec3 specularLightColor = normalize(vec3(1, 1, 1))*150.0;
        mediump vec3 reflectionDirection = normalize(reflect(-lightDirection, normalize(transformedNormal.xyz)));
        mediump float specularLuminance = pow(max(dot(reflectionDirection, eyeDirection), 0.0), 5.0);

        vLighting = (ambientLightColor * ambientLuminance +
                     directionalLightColor * directionalLuminance +
                     specularLightColor * specularLuminance
                   )/(lightDistance*lightDistance);
      }
    </script>
  </head>
  <body >
    <canvas id="canvas">
      WebGL not available, but happy christmas nonetheless <3
    </canvas>
  </body>
</html>
